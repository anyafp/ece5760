<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Starter Template for Bootstrap</title>

    <!-- Bootstrap core CSS -->
    <link href="dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <link href="../../assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet"> -->

    <!-- Custom styles for this template -->
    <link href="starter-template.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <!-- <script src="../../assets/js/ie-emulation-modes-warning.js"></script> -->

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Project name</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Home</a></li>
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#obj">Project Objective</a></li>
            <li><a href="#design">Design</a></li>
            <li><a href="#drawings">Drawings</a></li>
            <li><a href="#testing">Testing</a></li>
            <li><a href="#result">Result</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">

      <div class="starter-template">
        <h1>FPGA Gas Simulator</h1>
        <p class="lead">Anya Prabowo and Sarah Ellenbogen</p>
      </div>

      <hr>
      <div class="center-block">
          <iframe width="640" height="360" src="https://www.youtube.com/watch?v=hCmxI-XthL8&list=PLDqMkB5cbBA7nUwrxsLgtrOsce9UgJXJb&index=3" frameborder="0" allowfullscreen></iframe>
          <h4 style="text-align:center;">Demonstration Video</h4>
      </div>

      <hr id="intro">

      <div style="text-align:left;">
              <h2>Introduction</h2>
              <p style="text-align: left;padding: 0px 30px;">
<p>Our project aimed to simulate gas particles that follow the ideal gas laws, implemented on the FPGA.</p> 

<p>The gas simulation was done by representing particles with pixels that are printed on the VGA display, with collisions between particles being represented to follow the ideal gas laws. Several parameters were varied (pressure, volume of box, number of particles, and temperature) and observed the effects on the behavior of the particles.</p>

<p>We decided to simulate gas particles because we wanted to design a project that related to real life physics concepts, and thought that a visual representation of these concepts would be interesting.
</p>
      </div>

    <hr id='drawings'>

      <div style="text-align:center;">
              <h2>High Level Design</h2>
              <p style="text-align: left;padding: 0px 30px;">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum lorem nulla, consectetur at leo vel, pretium bibendum nisl. Cras blandit quam a enim ultrices, eu convallis enim posuere. Donec eleifend enim sed purus consectetur, vitae cursus lectus varius. Vivamus consectetur felis nec est venenatis posuere. Phasellus vitae aliquet erat. In laoreet lacinia mollis. Quisque iaculis nisl fermentum pharetra lobortis. Donec rhoncus dui sem, ac molestie leo tristique vel. Phasellus in nibh feugiat, fringilla lectus in, elementum magna. Etiam quis dui condimentum, tempus ex in, dapibus est. Cras ut congue augue. Donec ac enim ex. Ut id tristique risus, vel porttitor quam. Sed ultricies enim eu nibh porttitor, vel sodales enim feugiat. Fusce volutpat venenatis magna ac ultrices. Curabitur eget urna ut nulla mattis convallis non eu diam.</p>
      </div>

    <hr id='testing'>

      <div style="text-align:center;">
              <h2>Hardware</h2>
              <p style="text-align: left;padding: 0px 30px;">
                  <div style="text-align:left;">
                  <h4>Calculation (Particle) Module</h4> 
                  <p>We started off by writing a module to update the position of a single particle inside of a 2D box based on its current position and velocity, as well as the current size of the box. We based the velocity equations off of those from the boids lab in 4760. Given the position is in pixels and the velocity is in pixels per cycle, the update of the position every cycle is x = x0 + v. If the position of the particle at the next time step falls outside of the box, we reverse the velocity and calculate the position for the next time using the updated velocity. We reverse the particle before it hits the wall because it avoids the issue of tunneling, where the particle falls outside of the box before reversing. We also increment a hit counter in the module if we detect a collision and reverse a particle for future pressure calculations.</p>
                  
                     <h4>State Machine </h4> 
                     <p>The next step was to update the position of many particles within a certain time step. This required registers to store the current x and y position of the particle, in VGA coordinates, and the current x and y velocities in pixels/frame. We also needed a single wire to hold the box size, which was the same for all particles, as well as a single wire to keep track of the hit count. At first we created many of the particle position update modules in parallel using a generate statement, which were connected to each of the registers through wire arrays the same size of the registers. We were still sequentially reading the outputs of these modules since we could only write one pixel to VGA memory at once. Due to this we realized we did not need to create all of this hardware in parallel. Instead we created a single wire connected to a module and we would change which registers these wires were connected to based on what particle we wanted to update. We did not waste any cycles through changing this register as we connected the wire to the register in the cycle we were reading it for the previous particle position and writing it to the VGA, so in the next cycle it would have the updated position for the current particle. We kept track of the current particle through an index register that counted up to the number of particles.</p>
                     <p>Timing was not an issue for us even as we scaled up the number of particles, and even at the smallest particle speed of 1 pixel/sec, the particles were moving very quickly across the screen. Due to this we added a configurable delay between updates of the state machine, which also aided in debugging. The state machine stays in the wait state until the set number of cycles has passed and then returns to the beginning of the state machine to update the position of the particles once again. Here we also increment a time step counter to keep track of how many loops through the state machine we have done. We were not seeing large enough pressure/collision number values that we could compare when only looking at one update of the state machine, so we decided to look at the number of collisions every 100 updates of the state machine. To do this we only change the value on the hits_pio wire once the time step counter hits 100 and then we reset the time step counter. </p>
                     <p>We also wanted to simulate some randomness in the initial positions of the particles, so we used a LFSR (linear feedback shift register) that was sequentially read for all of the particles. It is important to note that this is not pure random, and can be predicted if the algorithm is known. The module only needs to be reset once upon overall reset and then can be read every 13 cycles as it performs 13 shifts. We needed to modify the shift register to add a done signal to know when these 13 shifts have been successfully performed and we can read the output of the module. The instantiation state is only run once upon reset. We first instantiate the x position for all of the particles one at a time using an index counter. The LFSR returns a 13-bit value, but we ensure that the particles are spawned inside the box by masking the values based on the box size and shifting them to the center of the VGA ( 320 pixels - half the box size ). We were initially modding the output of the LFSR to get the values within the specific range of the box size, but realized this was using too much logic and we could get similar, but less exact results with masking. We then initialize the y values one at a time in the same manner and then the velocity values to one of 4 options based on the output of the LFSR (vx = -1 and vy = 0, vx = 1 and vy = 0, vx = 0 and vy = -1, vx = 0 and vy = 1). Since we were simulating collisions according to the HPP model, as will be discussed in the next section, our particles were moving in one of four directions, up, down, left and right. Also since we are assuming there is a constant temperature throughout the box and each particle is of the same element, they will all have the same speed, which we start at 1 pixel/frame. </p>
                     
                <h4>Collision Detection</h4>
                     <p>Once we were able to simulate many particles moving around together, interacting with the sides of the box, we needed to implement collision detection and logic between each of the particles. To cover comparisons between each particle we loop through each particle and compare it to each particle with a higher index than itself. Since in our final design each particle only occupies one pixel we simply compare the current x and y positions of both particles and if they overlap we then move into the collision logic, to change the velocities, which in turn changes the direction of movement. </p>
                     <p>Since we are following the HPP collision model and the particles can only move in 1 of 4 directions, there are a limited number of ways the particles can collide in terms of their respective velocities, more specifically 16 combinations. We created a case statement to handle the variety of combinations that uses the velocity of both particles as an input. </p>
                <h4>VGA</h4>
                <p>The VGA driver avoids bus transactions by writing directly to memory that is read by the VGA screen. Since we were not limited in timing we decided not to parallelize the VGA reads from memory with multiple M10k blocks. To draw on the VGA we write an 8-bit color to memory at an address corresponding to the desired pixel. </p>
                <p>Simulating the particle movements on the VGA required drawing the particles at the updated positions, while simultaneously erasing them at their previous positions. We again did this sequentially since we could only write one pixel to VGA memory at once, as we only had one memory block that the VGA was reading from. We again did this by keeping a running index of the current particle until we reached the total number of particles. Before updating the position of the particle we draw the old position, in terms of VGA coordinates black. One cycle after we connect the wire of the current particle to the update module we read the output of the module and then write white to the new position of the particle. </p>
                <p>While we update the position of the particles and redraw them with every loop of the state machine, we only clear the screen and redraw the box on reset, which occurs in the first few states. This is so the user can change the size of the box at runtime. We again clear the screen and draw the box one pixel at a time. For clearing the screen we loop through each pixel in a single row and draw it black, and once we reach the end of the row we increment the y pixel counter until we have cleared every row. For drawing the box, we have a state for each side of the box starting with the top side. Since the box size is square and in pixels we calculate the x or y coordinate to keep constant for that side, and then draw for the number of pixels updating the other coordinate. </p>
                
                <script src="https://gist.github.com/anyafp/cd01bec3c73fc8d110f89bfe28e19097.js"></script>
                
                <h4>PIO Ports and Interaction with HPS</h4>To make the parameters of the simulation, consisting of velocity, box size, and number of particles, customizable at run time as well as to send pressure data to the HPS we added several PIO ports to the Qsys bus. The pressure value on the PIO port changes after a specific number of increments of the time step counter as described above. When we change the number of particles, as well as the box size, we simply reset the state machine and initialization occurs with the new values. The challenge came with changing the velocity without restarting the simulation. We solved this issue by examining the sign of the current velocity registers during the wait state and changing the speed of the particles according to the value on the PIO port while maintaining the sign. </h4>
                  
                  
      </div>
      </div>
      

    <hr id='result'>

      <div style="text-align:center;">
              <h2>Result</h2>
              <p style="text-align: left;padding: 0px 30px;">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum lorem nulla, consectetur at leo vel, pretium bibendum nisl. Cras blandit quam a enim ultrices, eu convallis enim posuere. Donec eleifend enim sed purus consectetur, vitae cursus lectus varius. Vivamus consectetur felis nec est venenatis posuere. Phasellus vitae aliquet erat. In laoreet lacinia mollis. Quisque iaculis nisl fermentum pharetra lobortis. Donec rhoncus dui sem, ac molestie leo tristique vel. Phasellus in nibh feugiat, fringilla lectus in, elementum magna. Etiam quis dui condimentum, tempus ex in, dapibus est. Cras ut congue augue. Donec ac enim ex. Ut id tristique risus, vel porttitor quam. Sed ultricies enim eu nibh porttitor, vel sodales enim feugiat. Fusce volutpat venenatis magna ac ultrices. Curabitur eget urna ut nulla mattis convallis non eu diam.</p>
      </div>

    <hr>

    <div class="row" style="text-align:center;">
          <h2>Work Distribution</h2>
          <div style="text-align:center;">
              <img class="img-rounded" src="pics/group.jpg" alt="Generic placeholder image" style="width:80%;">
              <h4>Project group picture</h4>
          </div>
          <div class="col-md-6" style="font-size:16px">
              <img class="img-rounded" src="pics/a.png" alt="Generic placeholder image" width="240" height="240">
              <h3>Rick</h3>
              <p class="lead">netid@cornell.edu</p>
              <p>Designed the overall software architecture (Just being himself).
          </div>
          <div class="col-md-6" style="font-size:16px">
              <img class="img-rounded" src="pics/b.png" alt="Generic placeholder image" width="240" height="240">
              <h3>Morty</h3>
              <p class="lead">netid@cornell.edu</p>
              <p>Tested the overall system.
          </div>
      </div>

    <hr>
      <div style="font-size:18px">
          <h2>Parts List</h2>
          <ul>
              <li>Raspberry Pi $35.00</li>
              <li>Raspberry Pi Camera V2 $25.00</li>
              <a href="https://www.adafruit.com/product/1463"><li>NeoPixel Ring - $9.95</li></a>
              <li>LEDs, Resistors and Wires - Provided in lab</li>
          </ul>
          <h3>Total: $69.95</h3>
      </div>
      <hr>
      <div style="font-size:18px">
          <h2>References</h2>
          <a href="https://picamera.readthedocs.io/">PiCamera Document</a><br>
          <a href="http://www.micropik.com/PDF/SG90Servo.pdf">Tower Pro Servo Datasheet</a><br>
          <a href="http://getbootstrap.com/">Bootstrap</a><br>
          <a href="http://abyz.co.uk/rpi/pigpio/">Pigpio Library</a><br>
          <a href="https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/">R-Pi GPIO Document</a><br>

      </div>

    <hr>

      <div class="row">
              <h2>Code Appendix</h2>
              <pre><code>
// Hello World.c
int main(){
  printf("Hello World.\n");
}
              </code></pre>
      </div>

    </div><!-- /.container -->




    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>
    <script src="dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script> -->
  </body>
</html>
